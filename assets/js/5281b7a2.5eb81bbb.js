"use strict";(self.webpackChunkascii_ui=self.webpackChunkascii_ui||[]).push([[443],{5874:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"architecture","title":"How Everything Works","description":"ascii-ui.nvim is built on a declarative and reactive model, taking inspiration","source":"@site/docs/architecture.md","sourceDirName":".","slug":"/architecture","permalink":"/ascii-ui-docs/docs/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/rcasia/ascii-ui-docs/docs/architecture.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"useFunctionRegistry","permalink":"/ascii-ui-docs/docs/hooks/use_function_registry"}}');var o=t(4848),s=t(8453);const r={sidebar_position:4},a="How Everything Works",c={},l=[{value:"1. The Declarative Core",id:"1-the-declarative-core",level:2},{value:"2. The Reactive Loop (State is King)",id:"2-the-reactive-loop-state-is-king",level:2},{value:"3. Component Composition",id:"3-component-composition",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"how-everything-works",children:"How Everything Works"})}),"\n",(0,o.jsx)(n.p,{children:"ascii-ui.nvim is built on a declarative and reactive model, taking inspiration\nfrom modern component-based frameworks like React. This approach fundamentally\nchanges how you think about building your UI: instead of manually updating the\nscreen, you declare the desired state, and the framework handles the rest."}),"\n",(0,o.jsx)(n.h2,{id:"1-the-declarative-core",children:"1. The Declarative Core"}),"\n",(0,o.jsx)(n.p,{children:"You declare what you want your UI to look like at any point in time, rather than\nwriting sequential steps to manipulate the terminal buffer."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"+------------------+         +-----------------+\n| Your Component   |         | ascii-ui.nvim   |\n| (Render Function)| -------\x3e| (The Renderer)  |\n|                  |         |                 |\n| return {         |         |  Declares what  |\n|   Button(...),   |         |  the UI should  |\n|   Paragraph(...),|         |  look like, not |\n| }                |         |  how to draw it.|\n+------------------+         +-----------------+\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The Render Function as a Blueprint: Every custom component's render function is\na blueprint. When it executes, it returns a new description (a tree of components\nand blocks) based on the current data."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"No Direct Manipulation: You never directly call Neovim APIs to change text,\ncolors, or window positions within your components. You simply return a\ndefinition, and the framework ensures the final ASCII output matches that definition."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"2-the-reactive-loop-state-is-king",children:"2. The Reactive Loop (State is King)"}),"\n",(0,o.jsx)(n.p,{children:"The system is reactive, meaning the UI automatically responds to changes in\ndata. This is governed by the state management system:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"\n+-------------+    `setCount()`     +-----------------+    Re-render   +-----------+\n| User        | ------------------\x3e | Component State | -------------\x3e | Component |\n| Interaction |    triggers         | (e.g., `count`) |    (e.g., `count` updated)  | (Render Fn)\n+-------------+                     +-----------------+                 +-----v-----+\n                                                                              | Returns New\n                                                                              | UI Description\n                                                                              v\n                                                           +-------------------------+\n                                                           | ascii-ui.nvim Renderer  |\n                                                           | (Calculates & Applies   |\n                                                           |  Changes to Neovim UI)  |\n                                                           +-------------------------+\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"The Source of Truth"}),": useState: The ",(0,o.jsx)(n.code,{children:"ui.hooks.useState()"})," hook gives your\ncomponent a local memory (the state)."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"The State Setter"}),": When a user interacts with the UI (e.g., clicks a\nbutton) and your logic calls the state setter function\n(e.g., setCount(new_value)), this signals the change to the framework."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Automatic Re-render"}),": ascii-ui.nvim automatically schedules the\ncomponent's render function to run again. This starts the reactive loop:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"State Change \u2192\nRender Function Re-runs\u2192New UI Description \u2192\nFramework Updates Screen"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The framework calculates the most efficient way to apply the changes to the\nNeovim buffer, updating only what is necessary."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"3-component-composition",children:"3. Component Composition"}),"\n",(0,o.jsx)(n.p,{children:"Just as in React, UIs are built by composing small, isolated components."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"      +-----+\n      | App |\n      +--+--+\n         |\n         v\n    +---------------+\n    | SimpleCounter |\n    +-----+---------+\n          |\n    +-----+-----+\n    | Paragraph |\n    +-----------+\n    +-----------+\n    |   Button  |\n    +-----------+\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"A complex component (like an App) is simply a parent that renders several\nsmaller components (SimpleCounter, Button, etc.)."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Each component manages its own state and renders its own piece of the UI,\nmaking every part of your application modular and reusable."}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);