"use strict";(self.webpackChunkascii_ui=self.webpackChunkascii_ui||[]).push([[575],{6580:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"hooks/use_reducer","title":"useReducer Hook","description":"The useReducer hook in ascii-ui.nvim is a powerful tool for managing complex state logic within functional components. Inspired by React\u2019s useReducer, it is especially useful when state transitions depend on specific actions or when the next state depends on the previous one.","source":"@site/docs/hooks/use_reducer.md","sourceDirName":"hooks","slug":"/hooks/use_reducer","permalink":"/ascii-ui-docs/docs/hooks/use_reducer","draft":false,"unlisted":false,"editUrl":"https://github.com/rcasia/ascii-ui-docs/docs/hooks/use_reducer.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_label":"useReducer"},"sidebar":"tutorialSidebar","previous":{"title":"useEffect","permalink":"/ascii-ui-docs/docs/hooks/use_effect"},"next":{"title":"useFunctionRegistry","permalink":"/ascii-ui-docs/docs/hooks/use_function_registry"}}');var i=s(4848),r=s(8453);const c={sidebar_position:3,sidebar_label:"useReducer"},d="useReducer Hook",l={},a=[{value:"Overview",id:"overview",level:2},{value:"Signature",id:"signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"Usage",id:"usage",level:2},{value:"Basic Example",id:"basic-example",level:3},{value:"Multiple Actions",id:"multiple-actions",level:3},{value:"Comparison with useState",id:"comparison-with-usestate",level:3},{value:"Comparison with React&#39;s <code>useReducer</code>",id:"comparison-with-reacts-usereducer",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related",id:"related",level:2},{value:"References",id:"references",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsxs)(n.h1,{id:"usereducer-hook",children:[(0,i.jsx)(n.code,{children:"useReducer"})," Hook"]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"useReducer"})," hook in ",(0,i.jsx)(n.strong,{children:"ascii-ui.nvim"})," is a powerful tool for managing complex state logic within functional components. Inspired by ",(0,i.jsxs)(n.a,{href:"https://react.dev/reference/react/useReducer",children:["React\u2019s ",(0,i.jsx)(n.code,{children:"useReducer"})]}),", it is especially useful when state transitions depend on specific actions or when the next state depends on the previous one."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"useReducer"})," enables you to handle state updates through a ",(0,i.jsx)(n.strong,{children:"reducer function"}),", which receives the current state and an action, returning the new state. This approach is well-suited for cases where:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The next state depends on the previous state."}),"\n",(0,i.jsx)(n.li,{children:"Updates are triggered by action objects."}),"\n",(0,i.jsx)(n.li,{children:"State logic is complex or modular."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"signature",children:"Signature"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local getValue, dispatch = useReducer(reducerFn, initialValue)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"reducerFn"})," (",(0,i.jsx)(n.em,{children:"function"}),"): ",(0,i.jsx)(n.code,{children:"(state, action) -> newState"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"initialValue"})," (",(0,i.jsx)(n.em,{children:"any"}),"): The initial state value."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"reducerFn"}),(0,i.jsx)(n.td,{children:"function"}),(0,i.jsxs)(n.td,{children:["A function ",(0,i.jsx)(n.code,{children:"(state, action) -> newState"})," that determines how the state is updated."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"initialValue"}),(0,i.jsx)(n.td,{children:"any"}),(0,i.jsx)(n.td,{children:"The initial value for the state."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"action"})," object is typically structured as a table, e.g. ",(0,i.jsx)(n.code,{children:'{ type = "increment", params = { ... } }'}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"useReducer"})," returns two functions:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"getValue"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"function(): any"})}),(0,i.jsx)(n.td,{children:"Immediately returns the current state value."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dispatch"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"function(action: any)"})}),(0,i.jsx)(n.td,{children:"Dispatches an action to the reducer, updating state."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Note:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["You ",(0,i.jsx)(n.strong,{children:"call"})," ",(0,i.jsx)(n.code,{children:"getValue()"})," to get the current state value (it is not a wrapper or another function)."]}),"\n",(0,i.jsx)(n.li,{children:"This differs from React, where the state is a variable; in ascii-ui.nvim, it is a getter function."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.h3,{id:"basic-example",children:"Basic Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local useReducer = require("ascii-ui.hooks.use_reducer")\n\n-- Reducer function\nlocal function counterReducer(state, action)\n  if action.type == "increment" then\n    return { value = state.value + 1 }\n  elseif action.type == "decrement" then\n    return { value = state.value - 1 }\n  end\n  return state\nend\n\nlocal function CounterComponent()\n  local getCounter, dispatch = useReducer(counterReducer, { value = 0 })\n\n  return function()\n    local value = getCounter()\n    return {\n      -- Use value.value in your rendering logic\n      -- Call dispatch({ type = "increment" }) to update\n    }\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"multiple-actions",children:"Multiple Actions"}),"\n",(0,i.jsx)(n.p,{children:"You can define as many action types as needed in your reducer:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local function listReducer(state, action)\n  if action.type == "add" then\n    return vim.list_extend(state, { action.params.item })\n  elseif action.type == "remove" then\n    table.remove(state, action.params.index)\n    return state\n  end\n  return state\nend\n\nlocal getItems, dispatch = useReducer(listReducer, { "item1", "item2" })\ndispatch({ type = "add", params = { item = "item3" } })\nlocal items = getItems()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"comparison-with-usestate",children:"Comparison with useState"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"useReducer"})," is preferable when state logic is complex, involves multiple sub-values, or requires predictable state transitions based on actions."]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"useState"})," for simple, independent values."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h2,{id:"comparison-with-reacts-usereducer",children:["Comparison with React's ",(0,i.jsx)(n.code,{children:"useReducer"})]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"ascii-ui.nvim"}),(0,i.jsx)(n.th,{children:"React"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Initialization"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"useReducer(reducer, initVal)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"useReducer(reducer, initVal)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Access state"}),(0,i.jsxs)(n.td,{children:["Call getter: ",(0,i.jsx)(n.code,{children:"getValue()"})]}),(0,i.jsxs)(n.td,{children:["Use variable: ",(0,i.jsx)(n.code,{children:"state"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Dispatch action"}),(0,i.jsxs)(n.td,{children:["Call: ",(0,i.jsx)(n.code,{children:"dispatch(action)"})]}),(0,i.jsxs)(n.td,{children:["Call: ",(0,i.jsx)(n.code,{children:"dispatch(action)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Action shape"}),(0,i.jsx)(n.td,{children:"Any Lua value, but typically a table"}),(0,i.jsx)(n.td,{children:"Any value, typically an object"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Trigger re-render"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Yes"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Define your reducer function outside the component for readability."}),"\n",(0,i.jsx)(n.li,{children:"Always return a new state object or table (avoid mutating the current state directly)."}),"\n",(0,i.jsx)(n.li,{children:"Use clear, descriptive action types."}),"\n",(0,i.jsxs)(n.li,{children:["Use the getter (e.g., ",(0,i.jsx)(n.code,{children:"getValue()"}),") to read the current state within your render function."]}),"\n",(0,i.jsxs)(n.li,{children:["Do not use ",(0,i.jsx)(n.code,{children:"useReducer"})," inside loops or conditionals; always call it at the top level of your component."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./use_state",children:(0,i.jsx)(n.code,{children:"useState"})}),": Simpler state management for primitives and independent values."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./use_effect",children:(0,i.jsx)(n.code,{children:"useEffect"})}),": Run side effects after state changes."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/rcasia/ascii-ui.nvim/blob/main/lua/ascii-ui/hooks/use_reducer.lua",children:"ascii-ui.nvim source: use_reducer.lua"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://react.dev/reference/react/useReducer",children:"React documentation: useReducer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/rcasia/ascii-ui.nvim#readme",children:"ascii-ui.nvim README"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>d});var t=s(6540);const i={},r=t.createContext(i);function c(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);